import os
import re
import zipfile
from pathlib import Path
import json
import statistics
from collections import defaultdict, Counter

def extract_features_from_apk(apk_path):
    """Extract comprehensive features from APK using zip file analysis"""
    try:
        features = {}
        with zipfile.ZipFile(apk_path, 'r') as apk:
            # Get list of all files
            file_list = apk.namelist()

            # Extract AndroidManifest.xml
            try:
                manifest = apk.read('AndroidManifest.xml').decode('utf-8', errors='ignore')
            except:
                manifest = ""

            # Count total files
            features['total_files'] = len(file_list)

            # Count different file types
            features['dex_files'] = len([f for f in file_list if f.endswith('.dex')])
            features['jar_files'] = len([f for f in file_list if f.endswith('.jar')])
            features['so_files'] = len([f for f in file_list if f.endswith('.so')])
            features['xml_files'] = len([f for f in file_list if f.endswith('.xml')])
            features['png_files'] = len([f for f in file_list if f.endswith('.png')])
            features['jpg_files'] = len([f for f in file_list if f.endswith('.jpg')])
            features['txt_files'] = len([f for f in file_list if f.endswith('.txt')])

            # Check for common patterns in manifest
            permission_patterns = [
                'SEND_SMS', 'READ_SMS', 'RECEIVE_SMS', 'READ_CONTACTS',
                'INTERNET', 'READ_PHONE_STATE', 'ACCESS_FINE_LOCATION',
                'SYSTEM_ALERT_WINDOW', 'WRITE_EXTERNAL_STORAGE',
                'READ_EXTERNAL_STORAGE', 'RECEIVE_BOOT_COMPLETED',
                'REQUEST_IGNORE_BATTERY_OPTIMIZATIONS', 'WAKE_LOCK',
                'BIND_DEVICE_ADMIN', 'DISABLE_KEYGUARD',
                'ACCESS_COARSE_LOCATION', 'ACCESS_NETWORK_STATE',
                'CAMERA', 'RECORD_AUDIO', 'CHANGE_WIFI_STATE'
            ]

            for pattern in permission_patterns:
                features[f'has_{pattern.lower()}'] = 1 if pattern in manifest else 0

            # Count activities, services, and receivers
            features['activity_count'] = len(re.findall(r'<activity', manifest))
            features['service_count'] = len(re.findall(r'<service', manifest))
            features['receiver_count'] = len(re.findall(r'<receiver', manifest))
            features['provider_count'] = len(re.findall(r'<provider', manifest))

            # Check for suspicious file names
            suspicious_files = [
                'su', 'superuser', 'Superuser', 'rootkit',
                'exploit', 'hack', 'crack', 'ransom', 'encrypt',
                'decrypt', 'bitcoin', 'payment', 'admin', 'root'
            ]

            for sus_file in suspicious_files:
                features[f'has_{sus_file}'] = 0
                for fname in file_list:
                    if sus_file.lower() in fname.lower():
                        features[f'has_{sus_file}'] = 1
                        break

            # Check for encryption-related strings in any text files
            encryption_patterns = [
                'AES', 'RSA', 'encrypt', 'decrypt', 'key', 'crypto',
                'bitcoin', 'ransom', 'payment', 'unlock', 'lock', 'files'
            ]
            
            features['encryption_strings'] = 0
            for file_path in file_list:
                if file_path.endswith('.txt') or file_path.endswith('.xml') or file_path.endswith('.html'):
                    try:
                        content = apk.read(file_path).decode('utf-8', errors='ignore').lower()
                        for pattern in encryption_patterns:
                            if pattern.lower() in content:
                                features['encryption_strings'] += 1
                    except:
                        pass

            # Get APK size
            features['apk_size'] = Path(apk_path).stat().st_size / (1024*1024)  # Size in MB

            # Extract package name if possible
            package_match = re.search(r'package="([^"]+)"', manifest)
            if package_match:
                features['package_name'] = package_match.group(1)
            else:
                features['package_name'] = "unknown"

            # Count total permissions
            features['permission_count'] = sum(1 for k, v in features.items() 
                                            if k.startswith('has_') and not k.startswith('has_su') 
                                            and not k.startswith('has_exploit') and v == 1)

            return features

    except Exception as e:
        print(f"Error processing {apk_path}: {str(e)}")
        return None

def analyze_directory_differences(good_dir, bad_dir):
    """Compare features between collections of good and bad APKs to identify patterns"""
    
    # Lists to store features from all good and bad APKs
    good_features_list = []
    bad_features_list = []
    
    # Process all good APKs
    print(f"Processing good APKs from {good_dir}...")
    for filename in os.listdir(good_dir):
        if filename.endswith('.apk'):
            filepath = os.path.join(good_dir, filename)
            print(f"Extracting features from {filename}")
            features = extract_features_from_apk(filepath)
            if features:
                good_features_list.append(features)
    
    # Process all bad APKs
    print(f"Processing bad APKs from {bad_dir}...")
    for filename in os.listdir(bad_dir):
        if filename.endswith('.apk'):
            filepath = os.path.join(bad_dir, filename)
            print(f"Extracting features from {filename}")
            features = extract_features_from_apk(filepath)
            if features:
                bad_features_list.append(features)
    
    print(f"Processed {len(good_features_list)} good APKs and {len(bad_features_list)} bad APKs")
    
    if not good_features_list or not bad_features_list:
        return {"error": "Failed to extract features from APKs in one or both directories"}
    
    # Calculate statistics for numeric features
    numeric_features = [
        'total_files', 'dex_files', 'jar_files', 'so_files', 'xml_files',
        'activity_count', 'service_count', 'receiver_count', 'provider_count',
        'apk_size', 'permission_count', 'encryption_strings'
    ]
    
    # Dictionaries to store statistical data
    good_stats = {}
    bad_stats = {}
    
    for feature in numeric_features:
        good_values = [apk.get(feature, 0) for apk in good_features_list]
        bad_values = [apk.get(feature, 0) for apk in bad_features_list]
        
        if good_values:
            good_stats[feature] = {
                'min': min(good_values),
                'max': max(good_values),
                'mean': statistics.mean(good_values),
                'median': statistics.median(good_values),
                'stdev': statistics.stdev(good_values) if len(good_values) > 1 else 0
            }
        
        if bad_values:
            bad_stats[feature] = {
                'min': min(bad_values),
                'max': max(bad_values),
                'mean': statistics.mean(bad_values),
                'median': statistics.median(bad_values),
                'stdev': statistics.stdev(bad_values) if len(bad_values) > 1 else 0
            }
    
    # Calculate permission frequencies
    good_permission_freq = defaultdict(int)
    bad_permission_freq = defaultdict(int)
    
    for apk in good_features_list:
        for key, value in apk.items():
            if key.startswith('has_') and key not in ['has_superuser', 'has_su'] and value == 1:
                good_permission_freq[key] += 1
    
    for apk in bad_features_list:
        for key, value in apk.items():
            if key.startswith('has_') and key not in ['has_superuser', 'has_su'] and value == 1:
                bad_permission_freq[key] += 1
    
    # Convert to percentages
    good_permission_pct = {k: (v / len(good_features_list)) * 100 for k, v in good_permission_freq.items()}
    bad_permission_pct = {k: (v / len(bad_features_list)) * 100 for k, v in bad_permission_freq.items()}
    
    # Find permissions that are more common in bad APKs
    suspicious_permissions = []
    for perm, bad_pct in bad_permission_pct.items():
        good_pct = good_permission_pct.get(perm, 0)
        if bad_pct > good_pct + 10:  # At least 10% more common in bad APKs
            suspicious_permissions.append({
                'permission': perm[4:].upper(),
                'good_pct': good_pct,
                'bad_pct': bad_pct,
                'difference': bad_pct - good_pct
            })
    
    # Sort by difference
    suspicious_permissions.sort(key=lambda x: x['difference'], reverse=True)
    
    # Analyze permission combinations
    good_combinations = []
    bad_combinations = []
    
    for apk in good_features_list:
        combo = []
        for key, value in apk.items():
            if key.startswith('has_') and value == 1:
                combo.append(key[4:])
        good_combinations.append(combo)
    
    for apk in bad_features_list:
        combo = []
        for key, value in apk.items():
            if key.startswith('has_') and value == 1:
                combo.append(key[4:])
        bad_combinations.append(combo)
    
    # Look for concerning permission pairs
    good_pairs = Counter()
    bad_pairs = Counter()
    
    for combo in good_combinations:
        for i in range(len(combo)):
            for j in range(i+1, len(combo)):
                pair = tuple(sorted([combo[i], combo[j]]))
                good_pairs[pair] += 1
    
    for combo in bad_combinations:
        for i in range(len(combo)):
            for j in range(i+1, len(combo)):
                pair = tuple(sorted([combo[i], combo[j]]))
                bad_pairs[pair] += 1
    
    # Find pairs that are much more common in bad APKs
    suspicious_pairs = []
    for pair, bad_count in bad_pairs.items():
        good_count = good_pairs.get(pair, 0)
        bad_pct = (bad_count / len(bad_features_list)) * 100
        good_pct = (good_count / len(good_features_list)) * 100
        
        if bad_pct > good_pct + 10:
            suspicious_pairs.append({
                'permissions': f"{pair[0].upper()} + {pair[1].upper()}",
                'good_pct': good_pct,
                'bad_pct': bad_pct,
                'difference': bad_pct - good_pct
            })
    
    suspicious_pairs.sort(key=lambda x: x['difference'], reverse=True)
    
    # Generate malicious indicators based on our findings
    malicious_indicators = []
    
    # Add suspicious permission indicators
    for perm in suspicious_permissions[:5]:  # Top 5 suspicious permissions
        malicious_indicators.append(f"Has {perm['permission']} permission (found in {perm['bad_pct']:.1f}% of malicious apps vs {perm['good_pct']:.1f}% of benign apps)")
    
    # Add suspicious permission combination indicators
    for pair in suspicious_pairs[:3]:  # Top 3 suspicious combinations
        malicious_indicators.append(f"Has permission combination: {pair['permissions']} (found in {pair['bad_pct']:.1f}% of malicious apps vs {pair['good_pct']:.1f}% of benign apps)")
    
    # Add numeric feature indicators
    if bad_stats['service_count']['median'] > good_stats['service_count']['median'] + 1:
        malicious_indicators.append(f"High number of services (median {bad_stats['service_count']['median']} in malicious vs {good_stats['service_count']['median']} in benign)")
    
    if bad_stats['receiver_count']['median'] > good_stats['receiver_count']['median'] + 1:
        malicious_indicators.append(f"High number of receivers (median {bad_stats['receiver_count']['median']} in malicious vs {good_stats['receiver_count']['median']} in benign)")
    
    if bad_stats['permission_count']['median'] > good_stats['permission_count']['median'] + 2:
        malicious_indicators.append(f"Requests many permissions (median {bad_stats['permission_count']['median']} in malicious vs {good_stats['permission_count']['median']} in benign)")
    
    # Look for file type differences
    if bad_stats['so_files']['median'] > good_stats['so_files']['median'] + 1:
        malicious_indicators.append(f"Contains more native code files (median {bad_stats['so_files']['median']} SO files in malicious vs {good_stats['so_files']['median']} in benign)")
    
    # Create summary information
    summary = {
        "good_apps": {
            "count": len(good_features_list),
            "permissions": {
                "median": good_stats['permission_count']['median'],
                "mean": good_stats['permission_count']['mean']
            },
            "services": {
                "median": good_stats['service_count']['median'],
                "mean": good_stats['service_count']['mean']
            },
            "receivers": {
                "median": good_stats['receiver_count']['median'],
                "mean": good_stats['receiver_count']['mean']
            },
            "activities": {
                "median": good_stats['activity_count']['median'],
                "mean": good_stats['activity_count']['mean']
            }
        },
        "bad_apps": {
            "count": len(bad_features_list),
            "permissions": {
                "median": bad_stats['permission_count']['median'],
                "mean": bad_stats['permission_count']['mean']
            },
            "services": {
                "median": bad_stats['service_count']['median'],
                "mean": bad_stats['service_count']['mean']
            },
            "receivers": {
                "median": bad_stats['receiver_count']['median'],
                "mean": bad_stats['receiver_count']['mean']
            },
            "activities": {
                "median": bad_stats['activity_count']['median'],
                "mean": bad_stats['activity_count']['mean']
            }
        },
        "suspicious_permissions": [p['permission'] for p in suspicious_permissions[:10]],
        "suspicious_combinations": [p['permissions'] for p in suspicious_pairs[:5]],
    }
    
    # Generate a comprehensive Gemini prompt based on our findings
    gemini_prompt = f"""
    You are an Android security expert specializing in ransomware detection. Based on analysis of {len(good_features_list)} benign and {len(bad_features_list)} malicious APKs, these are key indicators of potentially malicious APKs:
    
    SUSPICIOUS PERMISSIONS:
    {chr(10).join('- ' + p['permission'] + f" ({p['bad_pct']:.1f}% vs {p['good_pct']:.1f}%)" for p in suspicious_permissions[:8])}
    
    SUSPICIOUS PERMISSION COMBINATIONS:
    {chr(10).join('- ' + p['permissions'] + f" ({p['bad_pct']:.1f}% vs {p['good_pct']:.1f}%)" for p in suspicious_pairs[:5])}
    
    MALICIOUS BEHAVIORS:
    {chr(10).join('- ' + indicator for indicator in malicious_indicators)}
    
    When analyzing an APK, look for these patterns:
    
    1. A benign app typically has around {good_stats['permission_count']['median']:.1f} permissions, while malicious apps have {bad_stats['permission_count']['median']:.1f} (median values)
    2. A benign app typically has {good_stats['service_count']['median']:.1f} services, while malicious apps have {bad_stats['service_count']['median']:.1f} (median values)
    3. A benign app typically has {good_stats['receiver_count']['median']:.1f} receivers, while malicious apps have {bad_stats['receiver_count']['median']:.1f} (median values)
    
    The most reliable indicator of malicious behavior is the combination of suspicious permissions with high counts of background components (services and receivers).
    """
    
    return {
        "good_stats": good_stats,
        "bad_stats": bad_stats,
        "suspicious_permissions": suspicious_permissions,
        "suspicious_pairs": suspicious_pairs,
        "summary": summary,
        "malicious_indicators": malicious_indicators,
        "gemini_prompt": gemini_prompt
    }

# Example usage
if __name__ == "__main__":
    # Check if directories exist
    if not os.path.exists("good"):
        print("Error: 'good' directory not found")
        os.makedirs("good", exist_ok=True)
        print("Created 'good' directory - place benign APKs here")
    
    if not os.path.exists("bad"):
        print("Error: 'bad' directory not found")
        os.makedirs("bad", exist_ok=True)
        print("Created 'bad' directory - place malicious APKs here")
    
    # Check if directories contain APKs
    good_apks = [f for f in os.listdir("good") if f.endswith('.apk')] if os.path.exists("good") else []
    bad_apks = [f for f in os.listdir("bad") if f.endswith('.apk')] if os.path.exists("bad") else []
    
    if not good_apks:
        print("Warning: No APK files found in the 'good' directory")
    
    if not bad_apks:
        print("Warning: No APK files found in the 'bad' directory")
    
    if good_apks and bad_apks:
        print(f"Found {len(good_apks)} good APKs and {len(bad_apks)} bad APKs")
        print("Starting analysis...")
        results = analyze_directory_differences("good", "bad")
        
        # Save results to a JSON file
        with open("apk_analysis_results.json", "w") as f:
            json.dump(results, f, indent=2)
        
        print("Analysis completed and saved to apk_analysis_results.json")
        print("\nSuspicious permissions (most significant):")
        for perm in results["suspicious_permissions"][:5]:
            print(f"- {perm['permission']}: {perm['bad_pct']:.1f}% in malicious vs {perm['good_pct']:.1f}% in benign")
        
        print("\nSuspicious permission combinations:")
        for pair in results["suspicious_pairs"][:3]:
            print(f"- {pair['permissions']}: {pair['bad_pct']:.1f}% in malicious vs {pair['good_pct']:.1f}% in benign")
        
        print("\nPossible malicious indicators:")
        for indicator in results["malicious_indicators"]:
            print(f"- {indicator}")
    else:
        print("\nCould not perform analysis due to missing APK files")
        print("Please place benign APKs in the 'good' directory and malicious APKs in the 'bad' directory")